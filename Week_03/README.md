学习笔记

# Week_03学习总结

**！！！*“使用二分查找........”*在最下面**

已连续三周无法保质保量完成学习任务，遂在完成最低要求后，从头学习复习整理每一道题。

仍在整理第一周，当前周仅简单整理了二分查找这一节。

## 作业简记

### ?+2. 搜索旋转排序数组（33_中等）

// 1. 不讲武德之暴力遍历 O(n) O(1)
//  阅后即焚，此法免提

// 2. 减治二分 O(logn) O(1)
//  **尚未完全理解**

### ?+3. 搜索二维矩阵（74_中等）

// 1. 不讲武德之乌龟爬
//  从右上角往下爬到所在行，再往左爬

// 2. 二分查找 O(logn) O(1)
//  **尚未完全理解且待优化**

### ?+4. 寻找旋转排序数组中的最小值（153_中等）

// 1. 不讲武德之暴力遍历 O(n) O(1)
//  阅后即焚，此法免提

// 2. 二分查找 O(logn) O(1)

## 课后作业

**使用二分查找，寻找一个半有序数组 [4, 5, 6, 7, 0, 1, 2] 中间无序的地方。同学们可以将自己的思路、代码写在学习总结中。**

为节省时间，自行明确了限定条件，并只描述关键部分
### 按照“Leetcode--153.寻找旋转排序数组中的最小值”的限定条件：

2. `1 <= nums.length <= 5000`
3. `-5000 <= nums[i] <= 5000`
4. `nums` 中的所有整数都是 **唯一** 的
5. `nums` 原来是一个升序排序的数组，但在预先未知的某个点上进行了旋转

数组发生旋转后，**最大值必然在最小值左侧且相邻**，它们的index即为数组中间无序的地方
这里不妨**视最小值的index为数组无序的地方**
以下函数返回最小值的index：

```c
int locate(int* nums, int numsSize){
    int left = 0;
    int right = numsSize - 1;
    int mid = 0;
    while (left < right) {
        mid = left + (right - left) / 2;
        if (nums[mid] > nums[right])    left = mid + 1;
        else    right = mid;
    } 
    return left;
}
```

